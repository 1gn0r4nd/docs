"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[148],{6396:function(e,t,n){n.d(t,{Z:function(){return p}});var r=n(3117),a=n(7294),o=n(2389),i=n(9443);var s=function(){var e=(0,a.useContext)(i.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},l=n(6681),c=n(6010),u="tabItem_1uMI";function d(e){var t,n,r,o=e.lazy,i=e.block,d=e.defaultValue,p=e.values,h=e.groupId,m=e.className,f=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),k=null!=p?p:f.map((function(e){var t=e.props;return{value:t.value,label:t.label}})),v=(0,l.lx)(k,(function(e,t){return e.value===t.value}));if(v.length>0)throw new Error('Docusaurus error: Duplicate values "'+v.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var w=null===d?d:null!=(t=null!=d?d:null==(n=f.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(r=f[0])?void 0:r.props.value;if(null!==w&&!k.some((function(e){return e.value===w})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+w+'" but none of its children has the corresponding value. Available values are: '+k.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=s(),g=y.tabGroupChoices,b=y.setTabGroupChoices,C=(0,a.useState)(w),N=C[0],q=C[1],T=[],_=(0,l.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var D=g[h];null!=D&&D!==N&&k.some((function(e){return e.value===D}))&&q(D)}var A=function(e){var t=e.currentTarget,n=T.indexOf(t),r=k[n].value;r!==N&&(_(t),q(r),null!=h&&b(h,r))},K=function(e){var t,n=null;switch(e.key){case"ArrowRight":var r=T.indexOf(e.currentTarget)+1;n=T[r]||T[0];break;case"ArrowLeft":var a=T.indexOf(e.currentTarget)-1;n=T[a]||T[T.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":i},m)},k.map((function(e){var t=e.value,n=e.label;return a.createElement("li",{role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,className:(0,c.Z)("tabs__item",u,{"tabs__item--active":N===t}),key:t,ref:function(e){return T.push(e)},onKeyDown:K,onFocus:A,onClick:A},null!=n?n:t)}))),o?(0,a.cloneElement)(f.filter((function(e){return e.props.value===N}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},f.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==N})}))))}function p(e){var t=(0,o.Z)();return a.createElement(d,(0,r.Z)({key:String(t)},e))}},7332:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return c},default:function(){return h},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return d}});var r=n(3117),a=n(102),o=(n(7294),n(3905)),i=(n(6396),n(9055)),s=["components"],l={id:"setup",title:"\ud83c\udf92 Setup"},c=void 0,u={unversionedId:"sdk/workshop/setup",id:"sdk/workshop/setup",title:"\ud83c\udf92 Setup",description:"Node.js",source:"@site/docs/sdk/1-workshop/01-setup.md",sourceDirName:"sdk/1-workshop",slug:"/sdk/workshop/setup",permalink:"/docs/sdk/workshop/setup",editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/sdk/1-workshop/01-setup.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"setup",title:"\ud83c\udf92 Setup"},sidebar:"sdk",previous:{title:"\ud83d\udc4b\ud83c\udffb Welcome",permalink:"/docs/sdk/workshop/welcome"},next:{title:"\ud83d\udc53 Overview",permalink:"/docs/sdk/workshop/overview"}},d=[{value:"Node.js",id:"nodejs",children:[],level:2},{value:"Your working folder",id:"your-working-folder",children:[],level:2},{value:"KILT-SDK",id:"kilt-sdk",children:[],level:2}],p={toc:d};function h(e){var t=e.components,n=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"nodejs"},"Node.js"),(0,o.kt)("p",null,"You need to have ",(0,o.kt)("a",{parentName:"p",href:"https://nodejs.org/"},"Node.js")," installed. Any stable (LTS) version is sufficient."),(0,o.kt)("h2",{id:"your-working-folder"},"Your working folder"),(0,o.kt)("p",null,"Easy one: create a new folder, named for example ",(0,o.kt)("inlineCode",{parentName:"p"},"kilt-rocks"),". This is where we'll be doing work for the rest of this tutorial."),(0,o.kt)("h2",{id:"kilt-sdk"},"KILT-SDK"),(0,o.kt)("p",null,"Navigate into your newly created folder ",(0,o.kt)("inlineCode",{parentName:"p"},"kilt-rocks"),"."),(0,o.kt)("p",null,"Install the KILT-SDK by running the following commands:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"yarn init -y\nyarn add @kiltprotocol/sdk-js\n")),(0,o.kt)("p",null,"Or with ",(0,o.kt)("inlineCode",{parentName:"p"},"npm"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm init -y\nnpm install @kiltprotocol/sdk-js\n")),(0,o.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Before you call any SDK functionality, you need to initialise the crypto libraries and configure the SDK.\nThis is done calling ",(0,o.kt)("inlineCode",{parentName:"p"},"await Kilt.init({ address })")," where ",(0,o.kt)("inlineCode",{parentName:"p"},"address")," is the address of the full node you want to connect to.\nFor this workshop use ",(0,o.kt)("inlineCode",{parentName:"p"},"wss://peregrine.kilt.io"),"."))),(0,o.kt)("p",null,"Finally, it is a good idea to create a script to run through the workshop. Let's call it ",(0,o.kt)("inlineCode",{parentName:"p"},"index.js"),". We have prepared a file incase you need help here."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Reveal how to run the examples"),(0,o.kt)("p",null,(0,o.kt)(i.Z,{className:"language-js",mdxType:"CodeBlock"},"const Kilt = require('@kiltprotocol/sdk-js')\nconst { cryptoWaitReady } = require('@polkadot/util-crypto')\n\nconst { keystoreGeneration } = require('./2_1_did')\nconst { createClaimerLightDid } = require('./2_2_did')\nconst { createAttesterFullDid } = require('./2_3_did')\nconst { createCType } = require('./3_1_ctypeFromSchema')\nconst { ctypeStored } = require('./3_2_ctypeFromSchema')\nconst { createClaim } = require('./4_1_claim')\nconst { createRequestForAttestation } = require('./4_2_claim')\nconst { requestForAttestationReconstructed } = require('./5_1_attestation')\nconst { verifyRequest } = require('./5_2_attestation')\nconst { attestCredential } = require('./5_3_attestation')\nconst { verifyCredential } = require('./6_verification')\nconst { createPresentation } = require('./7_1_verification-with-nonce')\nconst { verifyPresentation } = require('./7_2_verification-with-nonce')\n\n// Copy created addresses and mnemonics from accounts.js\nconst claimerMnemonic = '<Claimer Mnemonic>'\nconst claimerAddress = '<Claimer Address>'\nconst attesterMnemonic = `<Attester Mnemonic>`\nconst attesterAddress = `<Attester Address>`\n\nasync function main() {\n  await cryptoWaitReady()\n  await Kilt.init({ address: 'wss://peregrine.kilt.io' })\n\n  // Fetch the keyring pair for the attester as in accounts using the generated mnemonic\n  const keyring = new Kilt.Utils.Keyring({\n    ss58Format: 38,\n    type: 'ed25519',\n  })\n  const attester = keyring.addFromMnemonic(attesterMnemonic)\n\n  // Creates a light DID for the claimer\n  const { claimerLightDid, keystore: claimerKeystore } =\n    await createClaimerLightDid(await keystoreGeneration(), claimerMnemonic)\n\n  // Checks if the attester has balance, if no balance has been found the script will end\n  if ((await Kilt.Balance.getBalances(attesterAddress)).free === 0) {\n    throw new Error(\n      `The following address: ${attesterAddress} holds no tokens, please request tokens from the faucet`\n    )\n  }\n\n  // Creates a full DID for the attester\n  const { attesterFullDid, keystore: attesterKeystore } =\n    await createAttesterFullDid(attester, attesterMnemonic, claimerKeystore)\n\n  // Creates a CType from a schema\n  const ctypeFromSchema = createCType()\n\n  // Checks to see if a CType is stored on-chain, if not stores the CType on-chain\n  const ctype = await ctypeStored(\n    attester,\n    attesterFullDid,\n    ctypeFromSchema,\n    attesterKeystore\n  )\n\n  // Creates a claim for the claimer\n  const claim = createClaim(claimerLightDid, ctype)\n\n  // Make a request for attestation to be sent to an Attester\n  const requestForAttestation = await createRequestForAttestation(\n    claimerLightDid,\n    claim,\n    claimerKeystore\n  )\n\n  // The claimer sends a request to an attester who reconstructs the request\n  if (!requestForAttestationReconstructed(requestForAttestation)) {\n    throw new Error('unable to construct the request for attestation')\n  }\n\n  // The attester verifies the request for an attestation\n  if (!(await verifyRequest(requestForAttestation))) {\n    throw new Error(\n      'The following requestion for attestation fails the attesters verification'\n    )\n  }\n\n  // Attests the request for attestation and anchors the attestation on-chain to create a credential\n  const credential = await attestCredential(\n    attester,\n    attesterFullDid,\n    requestForAttestation,\n    attesterKeystore\n  )\n\n  // Verifying the credential\n  if (!(await verifyCredential(credential))) {\n    throw new Error('The credential fails to be verified')\n  }\n\n  // A verifer would create and send a nonce for the claimer to use in the verification process, called a challenge\n  const nonce = Kilt.Utils.UUID.generate()\n\n  // Claimer creates a presentation to send to a verifier\n  const presentation = await createPresentation(\n    claimerLightDid,\n    credential,\n    nonce,\n    claimerKeystore\n  )\n\n  // A verifer receives the presentation and enters the nonce to verify\n  if (!(await verifyPresentation(presentation, nonce))) {\n    throw new Error(\n      'The claimers presentation of the credential fails to be verified'\n    )\n  }\n  await Kilt.disconnect()\n  return console.log('Congratulation you have completed the KILT workshop')\n}\n\nmain()\n"))),(0,o.kt)("p",null,"That's it for the basic setup - We're good to go!"))}h.isMDXComponent=!0}}]);