"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7550],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return h}});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var a=o.createContext({}),l=function(e){var n=o.useContext(a),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},c=function(e){var n=l(e.components);return o.createElement(a.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,a=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=l(t),h=r,y=u["".concat(a,".").concat(h)]||u[h]||d[h]||i;return t?o.createElement(y,s(s({ref:n},c),{},{components:t})):o.createElement(y,s({ref:n},c))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=u;var p={};for(var a in n)hasOwnProperty.call(n,a)&&(p[a]=n[a]);p.originalType=e,p.mdxType="string"==typeof e?e:r,s[1]=p;for(var l=2;l<i;l++)s[l]=t[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},62713:function(e,n,t){t.r(n),t.d(n,{assets:function(){return a},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return i},metadata:function(){return p},toc:function(){return l}});var o=t(83117),r=(t(67294),t(3905));const i={id:"session",title:"Setting Up the Communication Session"},s=void 0,p={unversionedId:"develop/dApp/session",id:"develop/dApp/session",title:"Setting Up the Communication Session",description:"The first step in creating your dApp is to set up the communication session. The purpose of the session is to pass encrypted messages back and forth between your dApp and the extension.",source:"@site/docs/develop/07_dApp/02_session.md",sourceDirName:"develop/07_dApp",slug:"/develop/dApp/session",permalink:"/docs/develop/dApp/session",draft:!1,editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/develop/07_dApp/02_session.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"session",title:"Setting Up the Communication Session"},sidebar:"dApp",previous:{title:"Overview",permalink:"/docs/develop/dApp/welcome"},next:{title:"Well Known DID Configuration",permalink:"/docs/develop/dApp/well-known-did-config"}},a={},l=[{value:"DApp indicates credential API support",id:"dapp-indicates-credential-api-support",level:2},{value:"DApp introduces itself",id:"dapp-introduces-itself",level:2},{value:"DApp checks the session values",id:"dapp-checks-the-session-values",level:2}],c={toc:l};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The first step in creating your dApp is to set up the communication session. The purpose of the session is to pass encrypted messages back and forth between your dApp and the extension."),(0,r.kt)("h2",{id:"dapp-indicates-credential-api-support"},"DApp indicates credential API support"),(0,r.kt)("p",null,"In order to indicate its support of the extension's API, the dApp creates the ",(0,r.kt)("inlineCode",{parentName:"p"},"window.kilt")," object as soon as possible. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<head>\n  <script>\n    window.kilt = {}\n  <\/script>\n</head>\n")),(0,r.kt)("h2",{id:"dapp-introduces-itself"},"DApp introduces itself"),(0,r.kt)("p",null,"The dApp introduces itself to the extension with its name, encryption key URI, and a challenge. A copy of the challenge should be stored on the server side. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { FullDidDetails } from '@kiltprotocol/did'\n\nconst did = 'did:kilt:example'\nconst dAppName = 'Your dApp Name'\n\nconst fullDid = await FullDidDetails.fromChainInfo(did)\n\nconst dAppEncryptionKeyUri = fullDid.assembleKeyUri(fullDid.encryptionKey.id)\n\n// generate and store challenge on the server side for the next step\nconst challenge = await fetch('/challenge')\n\nconst session = await window.kilt.sporran.startSession(\n  dAppName,\n  dAppEncryptionKeyUri,\n  challenge\n)\n")),(0,r.kt)("p",null,"At this point the extension has received the introduction of the dApp and returned a new session along with the encrypted challenge."),(0,r.kt)("h2",{id:"dapp-checks-the-session-values"},"DApp checks the session values"),(0,r.kt)("p",null,"The extension has provided the session along with an encrypted challenge. The dApp decrypts the challenge and verifies that it matches the original challenge. This should happen on the server side:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Crypto } from '@kiltprotocol/utils'\nimport { DidResolver } from '@kiltprotocol/did'\n\nconst { encryptionKeyUri, encryptedChallenge, nonce } = session\n\nconst encryptionKey = await DidResolver.resolveKey(encryptionKeyUri)\n\nconst { data } = await encryptionKeystore.decrypt({\n  data: Crypto.coToUInt8(encryptedChallenge),\n  nonce: Crypto.coToUInt8(nonce),\n  publicKey: keyAgreement.publicKey, // derived from your seed phrase\n  peerPublicKey: encryptionKey.publicKey,\n  alg: 'x25519-xsalsa20-poly1305',\n})\n\nconst decryptedChallenge = Crypto.u8aToHex(data)\n\n// Compare the decrypted challenge to the challenge you stored earlier\nif (decryptedChallenge === originalChallenge) {\n  return session\n}\n")),(0,r.kt)("p",null,"That's it! The communication session has been securely established and you're ready to start sending and receiving messages."))}d.isMDXComponent=!0}}]);